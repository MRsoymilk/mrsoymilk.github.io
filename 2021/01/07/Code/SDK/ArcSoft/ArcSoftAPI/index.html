

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>虹软人脸识别API [ Soymilk ]</title>
  
<link rel="shortcut icon" href="/favicon/favicon.ico">

<link rel="stylesheet" href="/lib/highlight/railscasts.css">

<link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">


<link rel="stylesheet" href="/css/milk.css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div class="milk-header">
     

  <nav class="header-nav">
     
    <ul class="nav-menu">
      
        <li id="Home">
          <i class="fa fa-home" aria-hidden="true"></i>
          <a href="/ ">Home</a>
        </li>
      
        <li id="Archives">
          <i class="fa fa-archive" aria-hidden="true"></i>
          <a href="/archives ">Archives</a>
        </li>
      
        <li id="About">
          <i class="fa fa-user-circle" aria-hidden="true"></i>
          <a href="/about ">About</a>
        </li>
      
    </ul>
    
    
      <span class="nav-date">
        <i class="fa fa-calendar" aria-hidden="true"></i>
        <span id="date"></span>
      </span>
    
    
    
      <span class="nav-system" id="nav-system"></span>
    
    
    <span class="nav-access">
      <i class="fa fa-universal-access" id="nav-access"></i>
      <i class="fa fa-angle-down"></i>
      <div class="dropdown-content" id="dropdown-content">
        <ul class="social">
          
            <li>
              <a href="https://github.com/MRsoymilk" target="_blank" rel="noopener">
                <i class="fa fa-github-alt" aria-hidden="true"></i>
              </a>
            </li>
          
            <li>
              <a href="mailto:codermrsoymilk@gmail.com">
                <i class="fa fa-envelope" aria-hidden="true"></i>
              </a>
            </li>
          
        </ul>
        <ul>
          <li><span>Power by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></span></li>
        </ul>
      </div>
    </span>
  </nav>
 
  </div>
  <div class="milk-body">
    
<div class="draggable-toc">
  <div class="toc-title">虹软人脸识别API</div>
  <p>process: <span>0</span></p>
  <div class="progress-container">
    <div class="progress-bar" id="bar"></div>
  </div>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetVersion"><span class="toc-text">ASFGetVersion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetActiveFileInfo"><span class="toc-text">ASFGetActiveFileInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFOnlineActivation"><span class="toc-text">ASFOnlineActivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFActivation"><span class="toc-text">ASFActivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFInitEngine"><span class="toc-text">ASFInitEngine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VIDEO模式"><span class="toc-text">VIDEO模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE模式"><span class="toc-text">IMAGE模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模式选择"><span class="toc-text">模式选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detectFaceOrientPriority"><span class="toc-text">detectFaceOrientPriority</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detectFaceScaleVal"><span class="toc-text">detectFaceScaleVal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#combinedMask"><span class="toc-text">combinedMask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFUninitEngine"><span class="toc-text">ASFUninitEngine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFDetectFaces"><span class="toc-text">ASFDetectFaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFDetectFacesEx"><span class="toc-text">ASFDetectFacesEx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFFaceFeatureExtract"><span class="toc-text">ASFFaceFeatureExtract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFFaceFeatureExtractEx"><span class="toc-text">ASFFaceFeatureExtractEx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFFaceFeatureCompare"><span class="toc-text">ASFFaceFeatureCompare</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFSetLivenessParam"><span class="toc-text">ASFSetLivenessParam</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFProcess"><span class="toc-text">ASFProcess</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#combinedMask-1"><span class="toc-text">combinedMask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFProcessEx"><span class="toc-text">ASFProcessEx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFProcess-IR"><span class="toc-text">ASFProcess_IR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFProcessEx-IR"><span class="toc-text">ASFProcessEx_IR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetAge"><span class="toc-text">ASFGetAge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetGender"><span class="toc-text">ASFGetGender</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetFace3DAngle"><span class="toc-text">ASFGetFace3DAngle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetLivenessScore"><span class="toc-text">ASFGetLivenessScore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASFGetLivenessScore-IR"><span class="toc-text">ASFGetLivenessScore_IR</span></a></li></ol>
</div>

<div class="post-content" id="post-content">
  <div id="top">虹软人脸识别API</div>
  <div class="post">
    
    <div class="content-categories">
      
      <i class="fa fa-location-arrow"></i>
      <ul>
        <li>categories</li>
        
          <li>&gt;</li>
          <li>
            <a href="/categories/Code/">
          Code
        </a>
          </li>
      
          <li>&gt;</li>
          <li>
            <a href="/categories/Code/SDK/">
          SDK
        </a>
          </li>
      
          <li>&gt;</li>
          <li>
            <a href="/categories/Code/SDK/ArcSoft/">
          ArcSoft
        </a>
          </li>
      
      </ul>
    
    </div>
    <hr>
    
    <p>版本：3.0.3902010101.5</p>
<p>参考：<code>ARCSOFT_ARC_FACE_DEVELOPER&#39;S_GUIDE.pdf</code></p>
<p>更为详尽的示例。</p>
<a id="more"></a>

<p>使用同一个引擎句柄不支持多线程调用同一个算法接口，需对同一个接口进行多线程调用需要启动多个引擎。</p>
<h2 id="ASFGetVersion"><a href="#ASFGetVersion" class="headerlink" title="ASFGetVersion"></a>ASFGetVersion</h2><p>获取SDK版本信息。无需激活或初始化即可调用。</p>
<pre><code class="cpp">const ASF_VERSION ASFGetVersion();</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    ASF_VERSION version = ASFGetVersion();
    cout &lt;&lt; version.Version &lt;&lt; endl;
    cout &lt;&lt; version.BuildDate &lt;&lt; endl;
    cout &lt;&lt; version.CopyRight &lt;&lt; endl;
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetActiveFileInfo"><a href="#ASFGetActiveFileInfo" class="headerlink" title="ASFGetActiveFileInfo"></a>ASFGetActiveFileInfo</h2><p>获取激活文件信息接口</p>
<pre><code class="cpp">MRESULT ASFGetActiveFileInfo(
    LPASF_ActiveFileInfo  activeFileInfo  // [out] 激活文件信息
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    ASF_ActiveFileInfo info;
    MRESULT res = ASFGetActiveFileInfo(&amp;info);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetActiveFileInfo fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFGetActiveFileInfo success: &quot; &lt;&lt; info.appId &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFOnlineActivation"><a href="#ASFOnlineActivation" class="headerlink" title="ASFOnlineActivation"></a>ASFOnlineActivation</h2><p>用于在线激活SDK。</p>
<p>初次使用SDK需要联网激活，激活成功后无需重复调用，可离线使用。</p>
<pre><code class="cpp">MRESULT ASFOnlineActivation(
    MPChar                AppId,            // [in]  APPID    官网下载
    MPChar                SDKKey            // [in]  SDKKEY    官网下载
);</code></pre>
<details>
<summary>示例</summary>

<pre><code class="cpp">#include &lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

#define APPID &quot;your_appid&quot;
#define SDKKEY &quot;your_sdkkey&quot;

int main() {
    MRESULT res = ASFOnlineActivation(APPID, SDKKEY);
    if (res != MOK &amp;&amp; res != MERR_ASF_ALREADY_ACTIVATED) {
        cout &lt;&lt; &quot;ASFOnlineActivation fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFOnlineActivation success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<p><strong>注意：</strong> 实际使用需要更改<code>ASFOnlineActivation</code>数据结构：</p>
<pre><code class="cpp">MRESULT ASFOnlineActivation(
    MPCChar                AppId,            // [in]  APPID    官网下载
    MPCChar                SDKKey            // [in]  SDKKEY    官网下载
);</code></pre>
<h2 id="ASFActivation"><a href="#ASFActivation" class="headerlink" title="ASFActivation"></a>ASFActivation</h2><p>用于在线激活SDK。</p>
<p>与<code>ASFOnlineActivation</code>功能一致。</p>
<pre><code class="cpp">MRESULT ASFActivation(
    MPChar                AppId,            // [in]  APPID    官网下载
    MPChar                SDKKey            // [in]  SDKKEY    官网下载
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

#define APPID &quot;your_appid&quot;
#define SDKKEY &quot;your_sdkkey&quot;

int main() {
    MRESULT res = ASFActivation(APPID, SDKKEY);
    if (res != MOK &amp;&amp; res != MERR_ASF_ALREADY_ACTIVATED) {
        cout &lt;&lt; &quot;ASFActivation fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFActivation success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<p><strong>注意：</strong> 实际使用需要更改<code>ASFActivation</code>数据结构：</p>
<pre><code class="cpp">MRESULT ASFActivation(
    MPCChar                AppId,            // [in]  APPID    官网下载
    MPCChar                SDKKey            // [in]  SDKKEY    官网下载
);</code></pre>
<h2 id="ASFInitEngine"><a href="#ASFInitEngine" class="headerlink" title="ASFInitEngine"></a>ASFInitEngine</h2><p>初始化引擎。</p>
<pre><code class="cpp">MRESULT ASFInitEngine(
    ASF_DetectMode        detectMode,                    // [in]    
    //         AF_DETECT_MODE_VIDEO 视频模式：适用于摄像头预览，视频文件识别
    //        AF_DETECT_MODE_IMAGE 图片模式：适用于静态图片的识别
    ASF_OrientPriority    detectFaceOrientPriority,    // [in]    检测脸部的角度优先值，参考 ArcFaceCompare_OrientPriority
    MInt32                detectFaceScaleVal,            // [in] 用于数值化表示的最小人脸尺寸，该尺寸代表人脸尺寸相对于图片长边的占比
    // video 模式有效值范围[2, 32], 推荐值为 16
    // image 模式有效值范围[2, 32], 推荐值为 32
    MInt32                detectFaceMaxNum,            // [in] 最大需要检测的人脸个数，取值范围[1, 50]
    MInt32                combinedMask,                // [in] 用户选择需要检测的功能组合，可单个或多个
    MHandle*            hEngine                        // [out] 初始化返回的引擎handle
);</code></pre>
<h3 id="VIDEO模式"><a href="#VIDEO模式" class="headerlink" title="VIDEO模式"></a>VIDEO模式</h3><ul>
<li>对视频流中的人脸进行追踪，人脸框平滑过渡，不会出现跳框现象。</li>
<li>使用摄像头需要做预览显示，每一帧都需要做人脸检测，人脸检测耗时短不会出现卡顿的现象。</li>
<li>视频模式下人脸追踪和带有一个<code>FaceId</code>值，标记一张人脸从进入画面直到离开画面。<code>FaceId</code>值不变，可用于业务中优化程序性能。</li>
</ul>
<h3 id="IMAGE模式"><a href="#IMAGE模式" class="headerlink" title="IMAGE模式"></a>IMAGE模式</h3><ul>
<li>针对单张图片进行人脸检测，精度更高。</li>
<li>注册人脸库时，建议使用精度更高的IMAGE模式。</li>
</ul>
<h3 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h3><ol>
<li>摄像头中获取数据并需要预览显示，推荐选择VIDEO模式；</li>
<li>处理静态图像数据，类似注册人脸库时，推荐使用IMAGE模式；</li>
<li>同时进行IMAGE模式人脸检测和VIDEO模式人脸检测，需要创建一个VIDEO模式的引擎和一个IMAGE模式的引擎。</li>
</ol>
<h3 id="detectFaceOrientPriority"><a href="#detectFaceOrientPriority" class="headerlink" title="detectFaceOrientPriority"></a>detectFaceOrientPriority</h3><p><img src="detect_face_orient_priority.png" alt="detect_face_orient_priority"></p>
<h3 id="detectFaceScaleVal"><a href="#detectFaceScaleVal" class="headerlink" title="detectFaceScaleVal"></a>detectFaceScaleVal</h3><p>识别的最小人脸比例 = 图片长边 / 人脸框长边比值</p>
<p>默认推荐值：VIDEO模式推荐16；IMAGE模式推荐32.</p>
<pre><code class="cpp">//如下图所示
//图片尺寸 400 x 600
//人脸尺寸 300 x 300

minScale = 600 / 300    //若为小数，向上取整（例如：2.53 取值为 3）</code></pre>
<p><img src="detect_face_scale.png" alt="detect_face_scale"></p>
<p><strong>设置推荐：</strong></p>
<p>根据使用场景适当调整。门禁场景推荐使用<code>VIDEO</code>模式，<code>detectFaceScaleVal</code>设置为16.</p>
<p>用户使用场景下的成像质量比较高，设置为32，可以在相对较远的位置检测到人脸并比对通过，效果更佳，达到无感通行。</p>
<h3 id="combinedMask"><a href="#combinedMask" class="headerlink" title="combinedMask"></a>combinedMask</h3><p>针对算法功能会有常量值与之一一对应，根据业务需求进行自由选择，不需要的属性可以不用初始化，减少内存占用。</p>
<pre><code class="cpp">#define ASF_FACE_DETECT     0x00000001     //人脸检测
#define ASF_FACERECOGNITION    0x00000004    //人脸特征
#define ASF_AGE             0x00000008    //年龄
#define ASF_GENDER            0x00000010    //性别
#define ASF_FACE3DANGLE     0x00000020    //3D角度
#define ASF_LIVENESS         0x00000080    //RGB活体
#define ASF_IR_LIVENESS     0x00000400    //IR活体</code></pre>
<p><strong>说明：</strong></p>
<ol>
<li>人脸识别一般需要<code>ASF_FACE_DETECT</code>和<code>ASF_FACERECOGNITION</code>属性。</li>
<li>需要防止纸张、屏幕等攻击可以传入<code>ASF_LIVENESS</code>和<code>ASF_IR_LIVENESS</code>，<code>RGB</code>和<code>IR</code>活体检测根据用户的摄像头类型以及实际的业务需求来决定如何选择。</li>
<li><code>ASF_AGE</code>/<code>ASF_GENDER</code>/<code>ASF_FACE3DANGLE</code>根据业务需求进行选择即可。</li>
</ol>
<p>这些属性均是以常量值进行定义，可通过|位运算符进行组合使用。</p>
<p>例如：<code>MInt32 combinedMask = ASF_FACE_DETECT | ASF_FACERECOGNITION |ASF_LIVENESS</code>。</p>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

#define APPID &quot;your_appid&quot;
#define SDKKEY &quot;your_sdkkey&quot;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 32;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    MRESULT res = ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
        );

    if (res != MOK) {
        cout &lt;&lt; &quot;ASFInitEngine fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFInitEngine success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFUninitEngine"><a href="#ASFUninitEngine" class="headerlink" title="ASFUninitEngine"></a>ASFUninitEngine</h2><p>销毁SDK引擎。</p>
<pre><code class="cpp">MRESULT ASFUninitEngine(
    MHandle hEngine
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS
        | ASF_IR_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    MRESULT res = ASFUninitEngine(handle);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFUninitEngine fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFUninitEngine success: &quot; &lt;&lt; res &lt;&lt; endl;
    }

    return 0;
}</code></pre>
</details>

<h2 id="ASFDetectFaces"><a href="#ASFDetectFaces" class="headerlink" title="ASFDetectFaces"></a>ASFDetectFaces</h2><p>VIDEO模式下调用人脸追踪功能。</p>
<p>IMAGE模式下调用人脸检测功能。</p>
<p>初始化中<code>detectFaceOrientPriority</code>、<code>detectFaceScaleVal</code>、<code>detectFaceMaxNum</code>参数的设置，对能否检测到人脸以及检测到几张人脸都有决定性作用。</p>
<p>图像宽度需要四字节对齐（宽度为4的倍数），否则需要裁剪。</p>
<pre><code class="cpp">MRESULT ASFDetectFaces(
    MHandle                hEngine,                            // [in] 引擎handle
    MInt32                width,                                // [in] 图片宽度
    MInt32                height,                                // [in] 图片高度
    MInt32                format,                                // [in] 颜色空间格式
    MUInt8*                imgData,                            // [in] 图片数据
    LPASF_MultiFaceInfo    detectedFaces,                        // [out]检测到的人脸信息 
    ASF_DetectModel        detectModel = ASF_DETECT_MODEL_RGB    // [in] 预留字段，当前版本使用默认参数即可
);</code></pre>
<p><img src="detect_faces.png" alt="detect_faces"></p>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv/cv.h&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 50;
    MInt32 mask = ASF_FACE_DETECT;

    MRESULT res_init = ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    if (res_init != MOK) {
        cout &lt;&lt; &quot;ASFInitEngine fail: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFInitEngine success: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }

    cv::Mat img = cv::imread(&quot;C:\\Users\\milk\\Desktop\\many.jpg&quot;);
    // 四字节对齐，原始图像裁剪
    cv::Rect area(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4);
    cv::Mat img_cut = img(area);
    ASF_MultiFaceInfo mult_face_info;
    MRESULT res_detect = ASFDetectFaces(
        handle,
        img_cut.cols,
        img_cut.rows,
        ASVL_PAF_RGB24_B8G8R8,
        img_cut.data,
        &amp;mult_face_info
    );
    if (res_detect != MOK) {
        cout &lt;&lt; &quot;ASFDetectFaces fail: &quot; &lt;&lt; res_detect &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFDetectFaces success: &quot; &lt;&lt; res_detect &lt;&lt; endl;

        cv::putText(img, &quot;face num: &quot; + to_string(mult_face_info.faceNum), cv::Point(30, 30), cv::FONT_ITALIC, 1, cv::Scalar(0, 0, 255), 2);
        for (int i = 0; i &lt; mult_face_info.faceNum; ++i) {
            cv::rectangle(
                img,
                cv::Point(mult_face_info.faceRect[i].left, mult_face_info.faceRect[i].top),
                cv::Point(mult_face_info.faceRect[i].right, mult_face_info.faceRect[i].bottom), 
                cv::Scalar(0, 0, 255), 
                2);
        }
    }

    cv::imshow(&quot;img&quot;, img);
    cv::waitKey(0);
    return 0;
}</code></pre>
</details>

<h2 id="ASFDetectFacesEx"><a href="#ASFDetectFacesEx" class="headerlink" title="ASFDetectFacesEx"></a>ASFDetectFacesEx</h2><p>与<code>ASFDetectFaces</code>功能一致，但采用结构体的形式传入图像数据，对更高精度的图像兼容性更好。</p>
<pre><code class="cpp">MRESULT ASFDetectFacesEx(
    MHandle                hEngine,                            // [in] 引擎handle
    LPASF_ImageData        imgData,                            // [in] 图片数据
    LPASF_MultiFaceInfo    detectedFaces,                        // [out] 检测到的人脸信息
    ASF_DetectModel        detectModel = ASF_DETECT_MODEL_RGB    // [in]    预留字段，当前版本使用默认参数即可
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv/cv.h&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 50;
    MInt32 mask = ASF_FACE_DETECT;

    MRESULT res_init = ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    if (res_init != MOK) {
        cout &lt;&lt; &quot;ASFInitEngine fail: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFInitEngine success: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }

    cv::Mat img = cv::imread(&quot;C:\\Users\\milk\\Desktop\\many.jpg&quot;);
    // 四字节对齐，原始图像裁剪
    cv::Rect area(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4);
    cv::Mat img_cut = img(area);

    // 使用结构体形式传入，对更高精度的图像兼容性更好
    ASVLOFFSCREEN asvl_img;
    asvl_img.i32Width = img_cut.cols;
    asvl_img.i32Height = img_cut.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;

    ASF_MultiFaceInfo mult_face_info;
    MRESULT res_detect = ASFDetectFacesEx(handle, &amp;asvl_img, &amp;mult_face_info);

    if (res_detect != MOK) {
        cout &lt;&lt; &quot;ASFDetectFaces fail: &quot; &lt;&lt; res_detect &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFDetectFaces success: &quot; &lt;&lt; res_detect &lt;&lt; endl;

        cv::putText(img, &quot;face num: &quot; + to_string(mult_face_info.faceNum), cv::Point(30, 30), cv::FONT_ITALIC, 1, cv::Scalar(0, 0, 255), 2);
        for (int i = 0; i &lt; mult_face_info.faceNum; ++i) {
            cv::rectangle(
                img, 
                cv::Point(mult_face_info.faceRect[i].left, mult_face_info.faceRect[i].top),
                cv::Point(mult_face_info.faceRect[i].right,mult_face_info.faceRect[i].bottom), 
                cv::Scalar(0, 0, 255), 
                2);
        }
    }

    cv::imshow(&quot;img&quot;, img);
    cv::waitKey(0);


    return 0;
}</code></pre>
</details>

<h2 id="ASFFaceFeatureExtract"><a href="#ASFFaceFeatureExtract" class="headerlink" title="ASFFaceFeatureExtract"></a>ASFFaceFeatureExtract</h2><p>单人脸特征提取。</p>
<p>在进行第二次特征提取时，覆盖第一次特征提取结果。</p>
<p>例如：1:1的比对分别对两张图片进行特征提取，若使用同一个引擎，第一次特征提取需要拷贝保存，再进行第二次特征提取，否则在比对时输出的结果为1。</p>
<pre><code class="cpp">MRESULT ASFFaceFeatureExtract(
    MHandle                    hEngine,        // [in]    引擎handle
    MInt32                    width,            // [in] 图片宽度
    MInt32                    height,            // [in] 图片高度
    MInt32                    format,            // [in] 颜色空间格式
    MUInt8*                    imgData,        // [in] 图片数据
    LPASF_SingleFaceInfo    faceInfo,        // [in] 单张人脸位置和角度信息
    LPASF_FaceFeature        feature            // [out] 人脸特征
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv/cv.h&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 50;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION;

    MRESULT res_init = ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    if (res_init != MOK) {
        cout &lt;&lt; &quot;ASFInitEngine fail: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFInitEngine success: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }

    cv::Mat img = cv::imread(&quot;C:\\Users\\milk\\Desktop\\many.jpg&quot;);
    // 四字节对齐，原始图像裁剪
    cv::Rect area(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4);
    cv::Mat img_cut = img(area);

    // 使用结构体形式传入，对更高精度的图像兼容性更好
    ASVLOFFSCREEN asvl_img;
    asvl_img.i32Width = img_cut.cols;
    asvl_img.i32Height = img_cut.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;

    ASF_MultiFaceInfo mult_face_info;

    MRESULT res_detect = ASFDetectFacesEx(handle, &amp;asvl_img, &amp;mult_face_info);

    if (res_detect != MOK) {
        cout &lt;&lt; &quot;ASFDetectFaces fail: &quot; &lt;&lt; res_detect &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFDetectFaces success: &quot; &lt;&lt; res_detect &lt;&lt; endl;

        cv::putText(img, &quot;face num: &quot; + to_string(mult_face_info.faceNum), cv::Point(30, 30), cv::FONT_ITALIC, 1, cv::Scalar(0, 0, 255), 2);
        for (int i = 0; i &lt; mult_face_info.faceNum; ++i) {
            cv::rectangle(
                img, 
                cv::Point(mult_face_info.faceRect[i].left, mult_face_info.faceRect[i].top),
                cv::Point(mult_face_info.faceRect[i].right, mult_face_info.faceRect[i].bottom), 
                cv::Scalar(0, 0, 255), 
                2);
            ASF_FaceFeature feature;
            ASF_SingleFaceInfo single_face_info;
            single_face_info.faceRect = mult_face_info.faceRect[i];
            single_face_info.faceOrient = mult_face_info.faceOrient[i];
            MRESULT res_extract = ASFFaceFeatureExtract(handle, img.cols, img.rows, ASVL_PAF_RGB24_B8G8R8, img.data, &amp;single_face_info, &amp;feature);
            cout &lt;&lt; &quot;Face: &quot; &lt;&lt; i &lt;&lt; &quot; --- &quot;;
            if (res_extract != MOK) {
                cout &lt;&lt; &quot;ASFFaceFeatureExtract faile: &quot; &lt;&lt; res_extract &lt;&lt; endl;
            }
            else {
                cout &lt;&lt; &quot;ASFFaceFeatureExtract success: &quot; &lt;&lt; res_extract &lt;&lt; endl;
            }
        }
    }

    cv::imshow(&quot;img&quot;, img);
    cv::waitKey(0);


    return 0;
}</code></pre>
</details>

<h2 id="ASFFaceFeatureExtractEx"><a href="#ASFFaceFeatureExtractEx" class="headerlink" title="ASFFaceFeatureExtractEx"></a>ASFFaceFeatureExtractEx</h2><p>单人脸特征提取。</p>
<p>与<code>ASFFaceFeatureExtract</code>功能一致，但采用结构体的形式传入图像数据，对更高精度的图像兼容性更好。</p>
<p>在进行第二次特征提取时，会覆盖第一次特征提取的结果。</p>
<ul>
<li>1:1的比对分别对两张图片进行特征提取，若使用同一个引擎，第一次特征提取需要拷贝保存，再进行第二次特征提取，否则在比对时输出的结果为1。</li>
<li>1:N搜索可以预先提取N张人脸特征存放在数据库或缓存中，进行比对识别。</li>
</ul>
<pre><code class="cpp">MRESULT ASFFaceFeatureExtractEx(
    MHandle                    hEngine,        // [in]    引擎handle
    LPASF_ImageData            imgData,        // [in] 图像数据
    LPASF_SingleFaceInfo    faceInfo,        // [in] 单张人脸位置和角度信息
    LPASF_FaceFeature        feature            // [out] 人脸特征
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv/cv.h&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 50;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION;

    MRESULT res_init = ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    if (res_init != MOK) {
        cout &lt;&lt; &quot;ASFInitEngine fail: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFInitEngine success: &quot; &lt;&lt; res_init &lt;&lt; endl;
    }

    cv::Mat img = cv::imread(&quot;C:\\Users\\milk\\Desktop\\many.jpg&quot;);
    // 四字节对齐，原始图像裁剪
    cv::Rect area(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4);
    cv::Mat img_cut = img(area);

    // 使用结构体形式传入，对更高精度的图像兼容性更好
    ASVLOFFSCREEN asvl_img;
    asvl_img.i32Width = img_cut.cols;
    asvl_img.i32Height = img_cut.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;

    ASF_MultiFaceInfo mult_face_info;

    MRESULT res_detect = ASFDetectFacesEx(handle, &amp;asvl_img, &amp;mult_face_info);

    if (res_detect != MOK) {
        cout &lt;&lt; &quot;ASFDetectFaces fail: &quot; &lt;&lt; res_detect &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFDetectFaces success: &quot; &lt;&lt; res_detect &lt;&lt; endl;

        cv::putText(img, &quot;face num: &quot; + to_string(mult_face_info.faceNum), cv::Point(30, 30), cv::FONT_ITALIC, 1, cv::Scalar(0, 0, 255), 2);
        for (int i = 0; i &lt; mult_face_info.faceNum; ++i) {
            cv::rectangle(
                img, 
                cv::Point(mult_face_info.faceRect[i].left, mult_face_info.faceRect[i].top),
                cv::Point(mult_face_info.faceRect[i].right, mult_face_info.faceRect[i].bottom), 
                cv::Scalar(0, 0, 255), 
                2);
            ASF_FaceFeature feature;
            ASF_SingleFaceInfo single_face_info;
            single_face_info.faceRect = mult_face_info.faceRect[i];
            single_face_info.faceOrient = mult_face_info.faceOrient[i];

            ASVLOFFSCREEN asvl_img;
            asvl_img.i32Width = img_cut.cols;
            asvl_img.i32Height = img_cut.rows;
            asvl_img.pi32Pitch[0] = img.step;
            asvl_img.ppu8Plane[0] = img.data;
            asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;

            MRESULT res_extract = ASFFaceFeatureExtractEx(handle, &amp;asvl_img, &amp;single_face_info, &amp;feature);
            cout &lt;&lt; &quot;Face: &quot; &lt;&lt; i &lt;&lt; &quot; --- &quot;;
            if (res_extract != MOK) {
                cout &lt;&lt; &quot;ASFFaceFeatureExtract faile: &quot; &lt;&lt; res_extract &lt;&lt; endl;
            }
            else {
                cout &lt;&lt; &quot;ASFFaceFeatureExtract success: &quot; &lt;&lt; res_extract &lt;&lt; endl;
            }
        }
    }

    cv::imshow(&quot;img&quot;, img);
    cv::waitKey(0);


    return 0;
}</code></pre>
</details>

<h2 id="ASFFaceFeatureCompare"><a href="#ASFFaceFeatureCompare" class="headerlink" title="ASFFaceFeatureCompare"></a>ASFFaceFeatureCompare</h2><p>人脸特征比对，输出比对相似度。</p>
<pre><code class="cpp">MRESULT ASFFaceFeatureCompare(
    MHandle                    hEngine,                        // [in] 引擎handle
    LPASF_FaceFeature        feature1,                        // [in] 待比较人脸特征1
    LPASF_FaceFeature        feature2,                        // [in] 待比较人脸特征2
    MFloat*                    confidenceLevel,                // [out] 比较结果，置信度数值
    ASF_CompareModel        compareModel = ASF_LIFE_PHOTO    // [in] 
    //         ASF_LIFE_PHOTO：用于生活照之间的特征比对，推荐阈值0.80
    //        ASF_ID_PHOTO：用于证件照或证件照和生活照之间的特征比对，推荐阈值0.82
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

#define SafeFree(p) { if ((p)) free(p); (p) = nullptr; }
using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 2;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    ASF_FaceFeature copyfeature_base = { 0 }, copyfeature_todo = { 0 };

    {
        cv::Mat img_base = cv::imread(&quot;C:\\users\\milk\\desktop\\1.jpg&quot;);
        img_base = img_base(cv::Rect(0, 0, img_base.cols - img_base.cols % 4, img_base.rows - img_base.rows % 4));
        ASF_MultiFaceInfo multi_base;
        ASF_SingleFaceInfo faceinfo_base = { 0 };
        ASF_FaceFeature feature_base;
        ASFDetectFaces(handle, img_base.cols, img_base.rows, ASVL_PAF_RGB24_B8G8R8, img_base.data, &amp;multi_base);
        cout &lt;&lt; &quot;num: &quot; &lt;&lt; multi_base.faceNum &lt;&lt; endl;
        faceinfo_base.faceRect = multi_base.faceRect[0];
        faceinfo_base.faceOrient = multi_base.faceOrient[0];
        ASFFaceFeatureExtract(handle, img_base.cols, img_base.rows, ASVL_PAF_RGB24_B8G8R8, img_base.data, &amp;faceinfo_base, &amp;feature_base);

        copyfeature_base.featureSize = feature_base.featureSize;
        copyfeature_base.feature = (MByte*)malloc(feature_base.featureSize);
        memset(copyfeature_base.feature, 0, feature_base.featureSize);
        memcpy(copyfeature_base.feature, feature_base.feature, feature_base.featureSize);
    }

    {
        cv::Mat img_todo = cv::imread(&quot;C:\\users\\milk\\desktop\\6.jpg&quot;);
        img_todo = img_todo(cv::Rect(0, 0, img_todo.cols - img_todo.cols % 4, img_todo.rows - img_todo.rows % 4));
        ASF_MultiFaceInfo multi_todo;
        ASF_SingleFaceInfo faceinfo_todo = { 0 };
        ASF_FaceFeature feature_todo;
        ASFDetectFaces(handle, img_todo.cols, img_todo.rows, ASVL_PAF_RGB24_B8G8R8, img_todo.data, &amp;multi_todo);
        cout &lt;&lt; &quot;num: &quot; &lt;&lt; multi_todo.faceNum &lt;&lt; endl;
        faceinfo_todo.faceRect = multi_todo.faceRect[0];
        faceinfo_todo.faceOrient = multi_todo.faceOrient[0];
        ASFFaceFeatureExtract(handle, img_todo.cols, img_todo.rows, ASVL_PAF_RGB24_B8G8R8, img_todo.data, &amp;faceinfo_todo, &amp;feature_todo);


        copyfeature_todo.featureSize = feature_todo.featureSize;
        copyfeature_todo.feature = (MByte*)malloc(feature_todo.featureSize);
        memset(copyfeature_todo.feature, 0, feature_todo.featureSize);
        memcpy(copyfeature_todo.feature, feature_todo.feature, feature_todo.featureSize);
    }

    MFloat result;
    ASFFaceFeatureCompare(handle, &amp;copyfeature_base, &amp;copyfeature_todo, &amp;result);
    cout &lt;&lt; result &lt;&lt; endl;
    SafeFree(copyfeature_base.feature);
    SafeFree(copyfeature_todo.feature);
    return 0;
}</code></pre>
</details>

<h2 id="ASFSetLivenessParam"><a href="#ASFSetLivenessParam" class="headerlink" title="ASFSetLivenessParam"></a>ASFSetLivenessParam</h2><p>设置RGB/IR活体阈值，若不设置内部默认RGB：0.5   IR：0.7</p>
<pre><code class="cpp">MRESULT ASFSetLivenessParam(
    MHandle                    hEngine,        // [in] 引擎handle
    LPASF_LivenessThreshold threshold        // [in] 活体置信度
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 2;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    ASF_LivenessThreshold threshold = { 0 };
    threshold.thresholdmodel_BGR = 0.5;
    threshold.thresholdmodel_IR = 0.7;
    MRESULT res = ASFSetLivenessParam(handle, &amp;threshold);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFSetLivenessParam fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFSetLivenessParam success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFProcess"><a href="#ASFProcess" class="headerlink" title="ASFProcess"></a>ASFProcess</h2><p>人脸属性检测（年龄、性别、人脸3D角度），最多支持4张人脸信息检测，超过部分返回未知（活体仅支持单张人脸检测，超出返回未知），接口不支持IR图像检测。</p>
<p>仅支持可见光图像检测。</p>
<pre><code class="cpp">MRESULT ASFProcess(
    MHandle                hEngine,            // [in] 引擎handle
    MInt32                width,                // [in] 图片宽度
    MInt32                height,                // [in] 图片高度
    MInt32                format,                // [in] 颜色空间格式
    MUInt8*                imgData,            // [in] 图片数据
    LPASF_MultiFaceInfo    detectedFaces,        // [in] 人脸信息，用户根据待检测的功能选择需要使用的人脸。
    MInt32                combinedMask        // [in] 只支持初始化时候指定需要检测的功能，在process时进一步在这个已经指定的功能集中继续筛选
    //      例如初始化的时候指定检测年龄和性别，在process的时候可以只检测年龄，但是不能检测除年龄和性别之外的功能    
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 2;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\fuck.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFaces(handle, img.cols, img.rows, ASVL_PAF_RGB24_B8G8R8, img.data, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;
    MInt32 process_mask = ASF_AGE | ASF_GENDER | ASF_FACE3DANGLE | ASF_LIVENESS;
    MRESULT result = ASFProcess(handle, img.cols, img.rows, ASVL_PAF_RGB24_B8G8R8, img.data, &amp;faces, process_mask);
    if (result != MOK) {
        cout &lt;&lt; &quot;ASFProcess fail: &quot; &lt;&lt; result &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFProcess success: &quot; &lt;&lt; result &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h3 id="combinedMask-1"><a href="#combinedMask-1" class="headerlink" title="combinedMask"></a>combinedMask</h3><p>process接口中支持检测<code>ASF_AGE</code>、<code>ASF_GENDER</code>、<code>ASF_FACE3DANGLE</code>、<code>ASF_LIVENESS</code>四种属性，但是想检测这些属性，必须在初始化引擎接口中对想要检测的属性进行初始化。</p>
<p>关于初始化接口中<code>combinedMask</code>和<code>ASFProcess</code>接口中<code>combinedMask</code>参数之间的关系：</p>
<ol>
<li><code>ASFProcess</code>接口中<code>combinedMask</code>支持传入的属性有<code>ASF_AGE</code>、<code>ASF_GENDER</code>、<code>ASF_FACE3DANGLE</code>、<code>ASF_LIVENESS</code>。</li>
<li>初始化中传入了<code>ASF_FACE_DETECT</code>、<code>ASF_FACERECOGNITION</code>、<code>ASF_AGE</code>、<code>ASF_LIVENESS</code>属性。</li>
<li><code>process</code>可传入属性组合只有<code>ASF_AGE</code>、<code>ASF_LIVENESS</code>、<code>ASF_AGE | ASF_LIVENESS</code>。</li>
</ol>
<h2 id="ASFProcessEx"><a href="#ASFProcessEx" class="headerlink" title="ASFProcessEx"></a>ASFProcessEx</h2><p>与<code>ASFProcess</code>功能一致，但采用结构体的形式传入图像数据，对更高精度的图像兼容任更好。</p>
<pre><code class="cpp">MRESULT ASFProcessEx(
    MHandle                hEngine,            // [in] 引擎handle
    LPASF_ImageData        imgData,            // [in] 图片数据
    LPASF_MultiFaceInfo detectedFaces,        // [in] 人脸信息，用户根据待检测的功能选择需要使用的人脸。
    MInt32                combinedMask        // [in] 只支持初始化时候指定需要检测的功能，在process时进一步在这个已经指定的功能集中继续筛选
    //      例如初始化的时候指定检测年龄和性别，在process的时候可以只检测年龄，但是不能检测除年龄和性别之外的功能 
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 2;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\fuck.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_AGE | ASF_GENDER | ASF_FACE3DANGLE | ASF_LIVENESS;

    MRESULT result = ASFProcessEx(handle, &amp;asvl_img, &amp;faces, process_mask);
    if (result != MOK) {
        cout &lt;&lt; &quot;ASFProcess fail: &quot; &lt;&lt; result &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFProcess success: &quot; &lt;&lt; result &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFProcess-IR"><a href="#ASFProcess-IR" class="headerlink" title="ASFProcess_IR"></a>ASFProcess_IR</h2><p>仅支持单人脸<code>IR</code>活体检测（不支持年龄、性别、3D角度的检测），超出返回未知。</p>
<pre><code class="cpp">MRESULT ASFProcess_IR(
    MHandle                hEngine,            // [in] 引擎handle
    MInt32                width,                // [in] 图片宽度
    MInt32                height,                // [in] 图片高度
    MInt32                format,                // [in] 颜色空间格式
    MUInt8*                imgData,            // [in] 图片数据
    LPASF_MultiFaceInfo    detectedFaces,        // [in] 人脸信息，用户根据待检测的功能选择需要使用的人脸。
    MInt32                combinedMask        // [in] 目前只支持传入ASF_IR_LIVENESS属性的传入，且初始化接口需要传入 
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS
        | ASF_IR_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\unreal.jpg&quot;);
    cv::cvtColor(img, img, CV_BGR2GRAY);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_GRAY;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_IR_LIVENESS;

    MRESULT res = ASFProcess_IR(handle, img.cols, img.rows, ASVL_PAF_GRAY, img.data, &amp;faces, process_mask);

    if (res != MOK) {
        cout &lt;&lt; &quot;ASFProcess_IR fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFProcess_IR success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFProcessEx-IR"><a href="#ASFProcessEx-IR" class="headerlink" title="ASFProcessEx_IR"></a>ASFProcessEx_IR</h2><p>与<code>ASFProcess_IR</code>功能一致，但采用结构体的形式传入图像数据，对更高精度的图像兼容性更好。</p>
<pre><code class="cpp">MRESULT ASFProcessEx_IR(
    MHandle                hEngine,            // [in] 引擎handle
    LPASF_ImageData        imgData,            // [in] 图片数据
    LPASF_MultiFaceInfo detectedFaces,        // [in] 人脸信息，用户根据待检测的功能选择需要使用的人脸。
    MInt32                combinedMask        // [in] 目前只支持传入ASF_IR_LIVENESS属性的传入，且初始化接口需要传入
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS
        | ASF_IR_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\unreal.jpg&quot;);
    cv::cvtColor(img, img, CV_BGR2GRAY);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));

    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_GRAY;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_IR_LIVENESS;

    MRESULT res = ASFProcessEx_IR(handle, &amp;asvl_img, &amp;faces, process_mask);

    if (res != MOK) {
        cout &lt;&lt; &quot;ASFProcessEx_IR fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFProcessEx_IR success: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetAge"><a href="#ASFGetAge" class="headerlink" title="ASFGetAge"></a>ASFGetAge</h2><p>获取年龄信息。</p>
<pre><code class="cpp">MRESULT ASFGetAge(
    MHandle hEngine,                // [in] 引擎handle
    LPASF_AgeInfo ageInfo            // [out] 检测到的年龄信息
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\ding.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_AGE | ASF_GENDER | ASF_FACE3DANGLE | ASF_LIVENESS;

    ASFProcessEx(handle, &amp;asvl_img, &amp;faces, process_mask);

    ASF_AgeInfo age = { 0 };
    MRESULT res = ASFGetAge(handle, &amp;age);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetAge fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;age: &quot; &lt;&lt; age.ageArray[0] &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetGender"><a href="#ASFGetGender" class="headerlink" title="ASFGetGender"></a>ASFGetGender</h2><p>获取性别信息。</p>
<pre><code class="cpp">MRESULT ASFGetGender(
    MHandle hEngine,                // [in] 引擎handle
    LPASF_GenderInfo genderInfo        // [out] 检测到的性别信息
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\17\\522627199707165616.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_AGE | ASF_GENDER | ASF_FACE3DANGLE | ASF_LIVENESS;

    ASFProcessEx(handle, &amp;asvl_img, &amp;faces, process_mask);

    ASF_GenderInfo gender = { 0 };
    MRESULT res = ASFGetGender(handle, &amp;gender);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetGender fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;gender: &quot;;
        if (gender.genderArray[0] == 1) {
            cout &lt;&lt; &quot;female&quot;;
        }
        else if (gender.genderArray[0] == 0) {
            cout &lt;&lt; &quot;male&quot;;
        }
        else {
            cout &lt;&lt; &quot;unknow&quot;;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetFace3DAngle"><a href="#ASFGetFace3DAngle" class="headerlink" title="ASFGetFace3DAngle"></a>ASFGetFace3DAngle</h2><p>获取3D角度信息。</p>
<pre><code class="cpp">MRESULT ASFGetFace3DAngle(
    MHandle hEngine,                    // [in] 引擎handle
    LPASF_Face3DAngle p3DAngleInfo        // [out] 检测到脸部3D 角度信息
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\17\\522627199707165616.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_AGE | ASF_GENDER | ASF_FACE3DANGLE | ASF_LIVENESS;

    ASFProcessEx(handle, &amp;asvl_img, &amp;faces, process_mask);

    ASF_Face3DAngle angle = { 0 };
    MRESULT res = ASFGetFace3DAngle(handle, &amp;angle);
    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetFace3DAngle fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;roll: &quot; &lt;&lt; angle.roll[0] &lt;&lt; &quot;\n&quot;
            &lt;&lt; &quot;yaw: &quot; &lt;&lt; angle.yaw[0] &lt;&lt; &quot;\n&quot;
            &lt;&lt; &quot;pitch: &quot; &lt;&lt; angle.pitch[0]
            &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetLivenessScore"><a href="#ASFGetLivenessScore" class="headerlink" title="ASFGetLivenessScore"></a>ASFGetLivenessScore</h2><p>获取RGB活体信息。</p>
<pre><code class="cpp">MRESULT ASFGetLivenessScore(
    MHandle hEngine,                    // [in] 引擎handle
    LPASF_LivenessInfo livenessInfo        // [out] 检测RGB活体结果
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS
        | ASF_IR_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\unreal.jpg&quot;);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_RGB24_B8G8R8;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_LIVENESS;
    ASFProcessEx(handle, &amp;asvl_img, &amp;faces, process_mask);
    ASF_LivenessInfo liveness = { 0 };
    MRESULT res = ASFGetLivenessScore(handle, &amp;liveness);

    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetLivenessScore fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFGetLivenessScore success: &quot; &lt;&lt; res &lt;&lt; endl;
        cout &lt;&lt; &quot;status: &quot; &lt;&lt; liveness.isLive[0] &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

<h2 id="ASFGetLivenessScore-IR"><a href="#ASFGetLivenessScore-IR" class="headerlink" title="ASFGetLivenessScore_IR"></a>ASFGetLivenessScore_IR</h2><p>获取IR活体结果</p>
<pre><code class="cpp">MRESULT ASFGetLivenessScore_IR(
    MHandle                hEngine,            // [in] 引擎handle
    LPASF_LivenessInfo     irLivenessInfo        // [out] 检测到IR活体结果
);</code></pre>
<details>
<summary>示例：</summary>

<pre><code class="cpp">#include &lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;

#include &quot;arcsoft_face_sdk.h&quot;
#include &quot;merror.h&quot;

#pragma comment(lib, &quot;libarcsoft_face_engine.lib&quot;)

using namespace std;

int main() {
    MHandle handle = nullptr;
    MInt32 scale = 16;
    MInt32 face_num = 1;
    MInt32 mask = ASF_FACE_DETECT
        | ASF_FACERECOGNITION
        | ASF_AGE
        | ASF_GENDER
        | ASF_FACE3DANGLE
        | ASF_LIVENESS
        | ASF_IR_LIVENESS;

    ASFInitEngine(
        ASF_DETECT_MODE_IMAGE,
        ASF_OP_0_ONLY,
        scale,
        face_num,
        mask,
        &amp;handle
    );

    cv::Mat img = cv::imread(&quot;C:\\users\\milk\\desktop\\unreal.jpg&quot;);
    cv::cvtColor(img, img, CV_BGR2GRAY);
    img = img(cv::Rect(0, 0, img.cols - img.cols % 4, img.rows - img.rows % 4));
    ASVLOFFSCREEN asvl_img;
    asvl_img.u32PixelArrayFormat = ASVL_PAF_GRAY;
    asvl_img.i32Width = img.cols;
    asvl_img.i32Height = img.rows;
    asvl_img.pi32Pitch[0] = img.step;
    asvl_img.ppu8Plane[0] = img.data;

    ASF_MultiFaceInfo faces = { 0 };
    ASFDetectFacesEx(handle, &amp;asvl_img, &amp;faces);
    cout &lt;&lt; &quot;face num: &quot; &lt;&lt; faces.faceNum &lt;&lt; endl;

    MInt32 process_mask = ASF_IR_LIVENESS;
    ASFProcessEx_IR(handle, &amp;asvl_img, &amp;faces, process_mask);

    ASF_LivenessInfo liveness = { 0 };
    MRESULT res = ASFGetLivenessScore_IR(handle, &amp;liveness);

    if (res != MOK) {
        cout &lt;&lt; &quot;ASFGetLivenessScore fail: &quot; &lt;&lt; res &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; &quot;ASFGetLivenessScore success: &quot; &lt;&lt; res &lt;&lt; endl;
        cout &lt;&lt; &quot;status: &quot; &lt;&lt; liveness.isLive[0] &lt;&lt; endl;
    }
    return 0;
}</code></pre>
</details>

    
    <hr>
    <div class="content-tags">
      
      <i class="fa fa-tags"></i>
      <ul>
        
        <li><a href="/tags/ArcSoft/">
          ArcSoft
        </a></li>
      
      </ul>
    
    </div>
    
     
<div class="comment-tabs" id="comment-tabs">
  comment:
  <ul>
    
      <li><a href="#Valine">Valine</a></li>
    
    
      <li><a href="#LiveRe">LiveRe</a></li>
    
    
      <li><a href="#ChangYan">ChangYan</a></li>
    
  </ul>
  
  
    <div id="ChangYan">
      <!--PC和WAP自适应版-->
      <div id="SOHUCS" ></div> 
      <script type="text/javascript"> 
      (function(){ 
      var appid = 'cyuGH4lBk'; 
      var conf = 'ae32d85e4ca99348209aedfd3ae01478'; 
      var width = window.innerWidth || document.documentElement.clientWidth; 
      if (width < 960) {
      var head = document.getElementsByTagName('head')[0]||document.head||document.documentElement;
      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.charset = 'utf-8';
      script.id = 'changyan_mobile_js';
      script.src = 'https://cy-cdn.kuaizhan.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf;
      head.appendChild(script);
      } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://cy-cdn.kuaizhan.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); 
      </script>
    </div>
   
  
  
    <div id="LiveRe">
      
        <!-- LiveRe City install code -->
        <div id="lv-container" data-id="city" data-uid="MTAyMC80NjA4MS8yMjU5Mg==">
          <script type="text/javascript">
            (function(d, s) {
              var j, e = d.getElementsByTagName(s)[0];
              if (typeof LivereTower === 'function') { return; }
              j = d.createElement(s);
              j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
              j.async = true;
              e.parentNode.insertBefore(j, e);
            })(document, 'script');
          </script>
          <noscript>Please activate JavaScript for write a comment in LiveRe</noscript>
          </div>
          <!-- completed City install code -->
        
    </div>
  
  
  
    <div id="Valine">
      <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
      <div id="vcomments"></div>
      <script>
        new Valine({
          el: '#vcomments',
          appId: '5bHFwYPW2iHWCiV7WmNRSenk-gzGzoHsz',
          appKey: '2q4UgVDTmeJf9Phe8VbnNKyC',
          avatar: 'monsterid',
          enableQQ: true
        })
      </script>
    </div>
   
</div>

  </div>
</div>
 
<div>
  <button id="scroll2top">back to top</button>
</div>
  </div>
  

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/jquery/jquery-ui.min.js"></script>


<script src="/lib/fancybox/jquery.fancybox.min.js"></script>



<script src="/lib/highlight/highlight.pack.js"></script>

<script>
  hljs.initHighlightingOnLoad();
</script>


<script src="/js/milk.js"></script>

</body>
</html>